import sys
import glob
import threading
import select
from collections import OrderedDict
import logging
import time
import json
import os
from i3situation.core import pluginManager
from i3situation.core import config


class Status():
    """
    Handles the running of the status utility and acts as the glue for the
    application.
    """
    def __init__(self):
        self.config = config.Config()
        self.outputDict = OrderedDict()
        self._configFilePath = self.config.configPath
        self._pluginPath = self.config.pluginPath
        self._configModTime = os.path.getmtime(self._configFilePath)
        self._pluginModTime = os.path.getmtime(self._pluginPath)
        logger = logging.getLogger()
        # If a stream handler has been attached, remove it.
        if logger.handlers:
            logger.removeHandler(logger.handlers[0])
        handler = logging.FileHandler(self.config.general['logFile'])
        logger.addHandler(handler)
        formatter = logging.Formatter(('[%(asctime)s] - %(levelname)s'
           ' - %(filename)s - %(funcName)s - %(message)s'),
           '%d/%m/%Y %I:%M:%S %p')
        handler.setFormatter(formatter)
        # Redirect stderr so that it doesn't confuse i3bar by outputting to it.
        self.logWriter = self.LoggingWriter(logger, logging.ERROR)
        sys.stderr = self.logWriter
        logger.setLevel(self.config.general['loggingLevel'])
        handler.setLevel(self.config.general['loggingLevel'])
        logging.debug('Config loaded from {0}'.format(self._configFilePath))
        logging.debug('Plugin path is located at {0}'.format(self._pluginPath))
        logging.debug('Last config modification time is: {0}'.format(self._configModTime))
        logging.debug('Last plugin directory modification time is: {0}'.format(self._pluginModTime))
        self.outputToBar(json.dumps({'version': 1, 'click_events': True}), False)
        self.outputToBar('[', False)
        logging.debug('Sent initial JSON data to i3bar.')
        logging.debug('Beginning plugin loading process')
        self.loader = pluginManager.PluginLoader(
            self._pluginPath, self.config.plugin)
        self.threadManager = pluginManager.ThreadManager(self.outputDict)
        # Event handling is done in another thread, so that the main thread
        # isn't stalled.
        self.eventThread = threading.Thread(target=self.handleEvents)
        self.eventThread.start()

    def outputToBar(self, message, comma=True):
        """
        Outputs data to stdout, without buffering.

        message: A string containing the data to be output.
        comma: Whether or not a comma should be placed at the end of the output.
        """
        if comma:
            message += ','
        sys.stdout.write(message + '\n')
        sys.stdout.flush()

    def reload(self):
        """
        Reload the installed plugins and the configuration file. This is called
        when either the plugins or config get updated.
        """
        logging.debug('Reloading config file as files have been modified.')
        self.config.plugin, self.config.general = self.config.reload()
        logging.debug('Reloading plugins as files have been modified.')
        self.loader = pluginManager.PluginLoader(
            self._pluginPath, self.config.plugin)
        self._pluginModTime = os.path.getmtime(self._pluginPath)
        self._configModTime = os.path.getmtime(self._configFilePath)

    def runPlugins(self):
        """
        Creates a thread for each plugin and lets the ThreadManager handle it.
        """
        for obj in self.loader.objects:
            # Reserve a slot in the outputDict in order to ensure that the
            # items are in the correct order.
            self.outputDict[obj._outputOptions['name']] = None
            self.threadManager.addThread(obj.main, obj.options['interval'])

    def run(self):
        """
        Monitors if the config file or plugins are updated. Also outputs the
        JSON data generated by the plugins, without needing to poll the threads.
        """
        self.runPlugins()
        while True:
            # Reload plugins and config if either the config file or plugin
            # directory are modified.
            if self._configModTime != os.path.getmtime(self._configFilePath) or \
                    self._pluginModTime != os.path.getmtime(self._pluginPath):
                self.threadManager.killAllThreads()
                self.outputDict.clear()
                self.reload()
                self.runPlugins()
            self.outputToBar(json.dumps(list(self.outputDict.values())))
            logging.debug('Output to bar')
            time.sleep(self.config.general['interval'])

    def handleEvents(self):
        """
        An event handler that processes events from stdin and calls the onClick
        function of the respective object. This function is run in another
        thread, so as to not stall the main thread.
        """
        for event in sys.stdin:
            if event.startswith('['):
                continue
            name = json.loads(event.lstrip(','))['name']
            for obj in self.loader.objects:
                if obj._outputOptions['name'] == name:
                    obj.onClick(json.loads(event.lstrip(',')))

    class LoggingWriter():
        """
        A simple class that provides a file like interface to the logging
        utility. Allows stderr to be redirected to logging.
        """
        def __init__(self, logger, level):
            self.logger = logger
            self.level = level

        def write(self, message):
            if message != '\n':
                self.logger.log(self.level, message)
